// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/js_engine/interpreter"

import {
  "dowdiness/js_engine/ast",
}

// Values
pub fn delete_array_like_element(Value, Int) -> Unit

pub fn detach_arraybuffer(Int) -> Unit

pub fn get_array_iterator_override(ArrayData) -> (Value?, Value?)

pub fn get_array_iterator_proto() -> Value

pub fn get_array_like_element(Value, Int) -> Value

pub fn get_array_method(ArrayData, String) -> Value

pub fn get_array_method_with_interp(ArrayData, String) -> Value

pub fn get_array_named_prop(ArrayData, String) -> Value?

pub fn get_arraybuffer_bytes(Int) -> Array[Int]?

pub fn get_async_iterator_symbol() -> SymbolData

pub fn get_buffer_id(Value) -> Int?

pub fn get_hasinstance_symbol() -> SymbolData

pub fn get_iterator_proto() -> Value

pub fn get_iterator_symbol() -> SymbolData

pub fn get_map_method(MapData, String) -> Value

pub fn get_match_symbol() -> SymbolData

pub fn get_number_method(Value, String) -> Value

pub fn get_promise_method(PromiseData, String) -> Value

pub fn get_regexp_string_iterator_proto() -> Value

pub fn get_replace_symbol() -> SymbolData

pub fn get_search_symbol() -> SymbolData

pub fn get_set_method(SetData, String) -> Value

pub fn get_split_symbol() -> SymbolData

pub fn get_string_iterator_proto() -> Value

pub fn get_string_method(String, String, annex_b? : Bool) -> Value

pub fn get_symbol_by_id(Int) -> SymbolData?

pub fn get_toprimitive_symbol() -> SymbolData

pub fn get_tostringtag_symbol() -> SymbolData

pub fn get_tostringtag_value(ObjectData) -> String? raise

pub fn get_typedarray_prop(ObjectData, String) -> Value

pub fn get_weakmap_method(ObjectData, String) -> Value

pub fn get_weakset_method(ObjectData, String) -> Value

pub fn has_array_like_element(Value, Int) -> Bool

pub fn is_arraybuffer_detached(Int) -> Bool

pub let is_constructing : Ref[Bool]

pub fn is_constructor_value(Value) -> Bool

pub fn is_function_value(Value) -> Bool

pub fn is_js_catchable_error(Error) -> Bool

pub fn is_truthy(Value) -> Bool

pub fn is_typedarray_class(String) -> Bool

pub fn js_error_to_throw_value(Error) -> Value

pub fn js_error_to_value(Error) -> Value

pub fn js_error_to_value_with_env(Error, Environment?) -> Value

pub fn make_array_iterator_value(ArrayData) -> Value

pub fn make_arraybuffer_object(Int, Value) -> Value

pub fn make_func(FuncData) -> Value

pub fn make_func_ext(FuncDataExt) -> Value

pub fn make_interp_method_func(String, Int, (Interpreter, Value, Array[Value]) -> Value raise) -> Value

pub fn make_method_func(String, Int, (Value, Array[Value]) -> Value raise) -> Value

pub fn make_native_func(String, (Array[Value]) -> Value raise) -> Value

pub fn make_native_func_with_length(String, Int, (Array[Value]) -> Value raise) -> Value

pub fn make_object(Map[String, Value], Value, Callable?, String, Map[String, PropDescriptor], Bool) -> Value

pub fn make_plain_object() -> Value

pub fn make_regex_match_array(RegexMatch, String) -> Value

pub fn make_regexp_object(String, String) -> Value

pub fn make_static_func(String, (Array[Value]) -> Value raise) -> Value

pub fn make_static_func_with_length(String, Int, (Array[Value]) -> Value raise) -> Value

pub fn make_string_iterator_value(String) -> Value

pub fn make_typedarray_object(String, Int, Value, Environment) -> Value

pub fn new_promise_data() -> PromiseData

pub fn new_symbol(String?) -> SymbolData

pub fn regex_match_at(String, String, String, Int) -> RegexMatch? raise

pub fn regex_search(String, String, String, start_pos? : Int) -> RegexMatch? raise

pub fn regex_search_all(String, String, String) -> Array[RegexMatch] raise

pub fn same_value(Value, Value) -> Bool

pub fn same_value_zero(Value, Value) -> Bool

pub fn set_array_iterator_override(ArrayData, Value?, Value?) -> Unit

pub fn set_array_like_element(Value, Int, Value) -> Unit

pub fn set_array_like_length(Value, Int) -> Unit

pub fn set_array_named_prop(ArrayData, String, Value) -> Unit

pub fn setup_arraybuffer_builtins(Environment) -> Unit

pub fn setup_builtins(Environment, Array[String], annex_b? : Bool) -> Unit

pub fn setup_dataview_builtins(Environment) -> Unit

pub fn setup_date_builtins(Environment) -> Unit

pub fn setup_generator_function_constructor(Environment, Value) -> Unit

pub fn setup_harness_builtins(Environment, Array[String], Value) -> Unit

pub fn setup_map_set_builtins(Environment) -> Unit

pub fn setup_object_builtins(Environment) -> Unit

pub fn setup_promise(Environment) -> Unit

pub fn setup_string_prototype(Value, annex_b? : Bool) -> Unit

pub fn setup_timers(Environment) -> Unit

pub fn setup_typedarray_builtins(Environment) -> Unit

pub fn setup_weakmap_set_builtins(Environment) -> Unit

pub fn strict_equal_val(Value, Value) -> Bool

pub fn string_match_regex(String, String, String) -> Value

pub fn string_replace_regex(String, String, String, String) -> Value

pub fn string_search_regex(String, String, String) -> Value

pub fn this_to_string(Value) -> String raise

pub fn to_array_like_elements(Value) -> Array[Value]

pub fn to_array_like_length(Value) -> Int

pub fn to_index(Value) -> Int raise

pub fn to_int32(Double) -> Int

pub fn to_number(Value) -> Double raise

pub fn type_of(Value) -> String

pub fn typed_array_bytes_per_element(String) -> Int

pub fn typedarray_get_index(ObjectData, Int) -> Value

pub fn typedarray_set_index(ObjectData, Int, Double) -> Unit

pub fn validate_typedarray_buffer(ObjectData) -> Unit raise

pub let well_known_async_iterator_sym : Ref[SymbolData?]

pub let well_known_hasinstance_sym : Ref[SymbolData?]

pub let well_known_iterator_sym : Ref[SymbolData?]

pub let well_known_match_sym : Ref[SymbolData?]

pub let well_known_replace_sym : Ref[SymbolData?]

pub let well_known_search_sym : Ref[SymbolData?]

pub let well_known_split_sym : Ref[SymbolData?]

pub let well_known_toprimitive_sym : Ref[SymbolData?]

pub let well_known_tostringtag_sym : Ref[SymbolData?]

// Errors
pub suberror GeneratorReturnSignal {
  GeneratorReturnSignal(Value)
}

pub suberror JsException {
  JsException(Value)
}

pub suberror YieldSignal {
  YieldSignal(Value)
}

// Types and methods
pub(all) struct ArrayData {
  elements : Array[Value]
}

type Binding

pub(all) enum BindingKind {
  LetBinding
  ConstBinding
  VarBinding
}
pub impl Eq for BindingKind
pub impl Show for BindingKind

pub(all) enum Callable {
  UserFunc(FuncData)
  ArrowFunc(FuncData)
  UserFuncExt(FuncDataExt)
  ArrowFuncExt(FuncDataExt)
  NativeCallable(String, (Array[Value]) -> Value raise)
  NonConstructableCallable(String, (Array[Value]) -> Value raise)
  BoundFunc(Value, Value, Array[Value])
  FuncCallMethod(Value)
  FuncApplyMethod(Value)
  MethodCallable(String, (Value, Array[Value]) -> Value raise)
  InterpreterCallable(String, (Interpreter, Value, Array[Value]) -> Value raise)
  ConstructorOnlyCallable(String, (Interpreter, Array[Value]) -> Value raise)
  ClassConstructor(String, Value, Value?, (Array[String], Array[@ast.Stmt])?, Environment, Value)
}

pub(all) struct Environment {
  bindings : Map[String, Binding]
  parent : Environment?
  mut is_var_scope : Bool
}
pub fn Environment::assign(Self, String, Value) -> Unit raise
pub fn Environment::assign_var(Self, String, Value) -> Unit raise
pub fn Environment::def(Self, String, Value, BindingKind) -> Unit raise
pub fn Environment::def_builtin(Self, String, Value) -> Unit
pub fn Environment::def_tdz(Self, String, BindingKind) -> Unit raise
pub fn Environment::find_var_env(Self) -> Self
pub fn Environment::get(Self, String) -> Value raise
pub fn Environment::has(Self, String) -> Bool
pub fn Environment::has_var(Self, String) -> Bool
pub fn Environment::initialize(Self, String, Value) -> Unit raise
pub fn Environment::new(parent? : Self?) -> Self

pub(all) struct FuncData {
  name : String?
  params : Array[String]
  body : Array[@ast.Stmt]
  closure : Environment
  strict : Bool
}

pub(all) struct FuncDataExt {
  name : String?
  params : Array[@ast.Param]
  rest_param : String?
  body : Array[@ast.Stmt]
  closure : Environment
  strict : Bool
}

pub(all) enum GenState {
  SuspendedStart
  Executing
  SuspendedYield
  Completed
}

pub(all) struct GeneratorObject {
  id : Int
  mut state : GenState
  body : Array[@ast.Stmt]
  params : Array[String]
  params_ext : Array[@ast.Param]?
  rest_param : String?
  closure : Environment
  name : String?
  interpreter : Interpreter
  args : Array[Value]
  this_val : Value
  mut env : Environment?
  mut pc : Int
  mut yield_value : Value
  mut resuming : Bool
  mut resume_action : ResumeAction
  mut try_resume_phase : Int
  mut try_resume_error : Value
  mut try_resume_result : Signal
  mut try_resume_pending_error : Error?
  loop_env_stack : Array[Environment]
  mut for_of_iterator : Value
  mut for_of_next : Value
  mut for_of_resume : Bool
  mut delegate_iterator : Value
  mut delegate_next : Value
  mut delegating : Bool
  mut yield_index : Int
  mut resume_at_yield : Int
}

pub(all) struct Interpreter {
  output : Array[String]
  global : Environment
  global_this : Value
  mut strict : Bool
  annex_b : Bool
  microtask_queue : Array[Microtask]
  timer_queue : Array[TimerTask]
  timer_id_counter : Ref[Int]
  timer_insertion_counter : Ref[Int]
  cancelled_timer_ids : Map[Int, Bool]
  module_registry : Map[String, Map[String, Value]]
  mut module_exports : Map[String, Value]
  mut module_export_bindings : Array[(String, String)]
}
pub fn Interpreter::enqueue_microtask(Self, Value, Array[Value]) -> Unit
pub fn Interpreter::new(annex_b? : Bool) -> Self
pub fn Interpreter::register_module(Self, String, Map[String, Value]) -> Unit
pub fn Interpreter::run(Self, Array[@ast.Stmt]) -> Value raise
pub fn Interpreter::run_microtasks(Self) -> Unit raise
pub fn Interpreter::run_module(Self, Array[@ast.Stmt]) -> Map[String, Value] raise
pub fn Interpreter::run_timers(Self) -> Unit raise

pub(all) struct MapData {
  entries : Array[(Value, Value)]
}

pub(all) struct Microtask {
  callback : Value
  args : Array[Value]
}

pub(all) struct ObjectData {
  properties : Map[String, Value]
  symbol_properties : Map[Int, Value]
  mut prototype : Value
  callable : Callable?
  class_name : String
  descriptors : Map[String, PropDescriptor]
  symbol_descriptors : Map[Int, PropDescriptor]
  mut extensible : Bool
}

pub(all) struct PromiseData {
  mut state : PromiseState
  mut result : Value
  fulfill_reactions : Array[PromiseReaction]
  reject_reactions : Array[PromiseReaction]
  mut is_handled : Bool
  properties : Map[String, Value]
  symbol_properties : Map[Int, Value]
  descriptors : Map[String, PropDescriptor]
  symbol_descriptors : Map[Int, PropDescriptor]
}

pub(all) struct PromiseReaction {
  handler : Value?
  resolve : Value
  reject : Value
  reaction_type : PromiseReactionType
}

pub(all) enum PromiseReactionType {
  Fulfill
  Reject
}

pub(all) enum PromiseState {
  Pending
  Fulfilled
  Rejected
}

pub(all) struct PropDescriptor {
  mut writable : Bool
  mut enumerable : Bool
  mut configurable : Bool
  mut getter : Value?
  mut setter : Value?
}

pub(all) struct ProxyData {
  mut target : Value?
  mut handler : Value?
}

type RegexMatch

pub(all) enum ResumeAction {
  NextAction
  ThrowAction(Value)
  ReturnAction(Value)
}

pub(all) enum ResumeKind {
  Next(Value)
  Throw(Value)
  Return(Value)
}

pub(all) struct SetData {
  values : Array[Value]
}

pub(all) enum Signal {
  Normal(Value)
  ReturnSignal(Value)
  BreakSignal(String?)
  ContinueSignal(String?)
}

pub(all) struct SymbolData {
  id : Int
  description : String?
}

pub(all) struct TimerTask {
  id : Int
  callback : Value
  args : Array[Value]
  delay : Int
  period : Int
  mut cancelled : Bool
  is_interval : Bool
  insertion_order : Int
}

pub(all) enum Value {
  Number(Double)
  String_(String)
  Bool(Bool)
  Null
  Undefined
  Object(ObjectData)
  Array(ArrayData)
  Symbol(SymbolData)
  Map(MapData)
  Set(SetData)
  Promise(PromiseData)
  Proxy(ProxyData)
}
pub impl Show for Value

// Type aliases

// Traits

