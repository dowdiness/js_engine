// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/js_engine/ast"

import {
  "dowdiness/js_engine/token",
}

// Values

// Errors

// Types and methods
pub(all) enum BinOp {
  Add
  Sub
  Mul
  Div
  Mod
  EqEq
  EqEqEq
  NotEq
  NotEqEq
  Lt
  Gt
  LtEq
  GtEq
  And
  Or
  NullishCoalesce
  BitAnd
  BitOr
  BitXor
  LShift
  RShift
  URShift
  Exp
  In
  Instanceof
}
pub impl Eq for BinOp
pub impl Show for BinOp

pub(all) struct ClassMethod {
  key : Expr
  value : Expr
  kind : PropKind
  computed : Bool
  is_static : Bool
}
pub impl Eq for ClassMethod
pub impl Show for ClassMethod

pub(all) enum CompoundOp {
  AddAssign
  SubAssign
  MulAssign
  DivAssign
  ModAssign
  ExpAssign
  BitAndAssign
  BitOrAssign
  BitXorAssign
  LShiftAssign
  RShiftAssign
  URShiftAssign
  LogicalAndAssign
  LogicalOrAssign
  NullishAssign
}
pub impl Eq for CompoundOp
pub impl Show for CompoundOp

pub(all) enum Expr {
  NumberLit(Double, @token.Loc)
  StringLit(String, @token.Loc)
  BoolLit(Bool, @token.Loc)
  NullLit(@token.Loc)
  UndefinedLit(@token.Loc)
  Ident(String, @token.Loc)
  Binary(BinOp, Expr, Expr, @token.Loc)
  Unary(UnaryOp, Expr, @token.Loc)
  Assign(String, Expr, @token.Loc)
  Call(Expr, Array[Expr], @token.Loc)
  Member(Expr, String, @token.Loc)
  Ternary(Expr, Expr, Expr, @token.Loc)
  FuncExpr(String?, Array[String], Array[Stmt], @token.Loc)
  FuncExprExt(String?, Array[Param], String?, Array[Stmt], @token.Loc)
  Grouping(Expr, @token.Loc)
  ObjectLit(Array[Property], @token.Loc)
  ArrayLit(Array[Expr], @token.Loc)
  ComputedMember(Expr, Expr, @token.Loc)
  MemberAssign(Expr, String, Expr, @token.Loc)
  ComputedAssign(Expr, Expr, Expr, @token.Loc)
  NewExpr(Expr, Array[Expr], @token.Loc)
  ThisExpr(@token.Loc)
  UpdateExpr(UpdateOp, Expr, Bool, @token.Loc)
  CompoundAssign(CompoundOp, Expr, Expr, @token.Loc)
  Comma(Expr, Expr, @token.Loc)
  TemplateLit(Array[String], Array[Expr], @token.Loc)
  ArrowFunc(Array[String], Array[Stmt], @token.Loc)
  ArrowFuncExt(Array[Param], String?, Array[Stmt], @token.Loc)
  SpreadExpr(Expr, @token.Loc)
  RegexLit(String, String, @token.Loc)
  DestructureAssign(Pattern, Expr, @token.Loc)
  OptionalMember(Expr, String, @token.Loc)
  OptionalComputedMember(Expr, Expr, @token.Loc)
  OptionalCall(Expr, Array[Expr], @token.Loc)
  ClassExpr(String?, Expr?, Array[ClassMethod], @token.Loc)
  SuperCall(Array[Expr], @token.Loc)
  SuperMember(String, @token.Loc)
  SuperComputedMember(Expr, @token.Loc)
}
pub impl Eq for Expr
pub impl Show for Expr

pub(all) struct Param {
  name : String
  default_val : Expr?
}
pub impl Eq for Param
pub impl Show for Param

pub(all) enum Pattern {
  IdentPat(String)
  ArrayPat(Array[Pattern?], Pattern?)
  ObjectPat(Array[PropPat], Pattern?)
}
pub impl Eq for Pattern
pub impl Show for Pattern

pub(all) struct Program {
  stmts : Array[Stmt]
}
pub impl Eq for Program
pub impl Show for Program

pub(all) enum PropKind {
  Init
  Get
  Set
}
pub impl Eq for PropKind
pub impl Show for PropKind

pub(all) struct PropPat {
  key : String
  value : Pattern
  default_val : Expr?
}
pub impl Eq for PropPat
pub impl Show for PropPat

pub(all) struct Property {
  key : Expr
  value : Expr
  kind : PropKind
  computed : Bool
}
pub impl Eq for Property
pub impl Show for Property

pub(all) enum Stmt {
  ExprStmt(Expr, @token.Loc)
  VarDecl(VarKind, String, Expr?, @token.Loc)
  Block(Array[Stmt], @token.Loc)
  StmtList(Array[Stmt], @token.Loc)
  IfStmt(Expr, Stmt, Stmt?, @token.Loc)
  WhileStmt(Expr, Stmt, @token.Loc)
  ForStmt(Stmt?, Expr?, Expr?, Stmt, @token.Loc)
  FuncDecl(String, Array[String], Array[Stmt], @token.Loc)
  FuncDeclExt(String, Array[Param], String?, Array[Stmt], @token.Loc)
  ReturnStmt(Expr?, @token.Loc)
  BreakStmt(String?, @token.Loc)
  ContinueStmt(String?, @token.Loc)
  ThrowStmt(Expr, @token.Loc)
  TryCatchStmt(Array[Stmt], String?, Array[Stmt]?, Array[Stmt]?, @token.Loc)
  SwitchStmt(Expr, Array[SwitchCase], @token.Loc)
  DoWhileStmt(Stmt, Expr, @token.Loc)
  ForInStmt(VarKind?, String, Expr, Stmt, @token.Loc)
  ForOfStmt(VarKind?, String, Expr, Stmt, @token.Loc)
  DestructureDecl(VarKind, Pattern, Expr, @token.Loc)
  LabeledStmt(String, Stmt, @token.Loc)
  ClassDecl(String, Expr?, Array[ClassMethod], @token.Loc)
}
pub impl Eq for Stmt
pub impl Show for Stmt

pub(all) struct SwitchCase {
  condition : Expr?
  body : Array[Stmt]
}
pub impl Eq for SwitchCase
pub impl Show for SwitchCase

pub(all) enum UnaryOp {
  Neg
  Not
  Typeof
  Void
  Delete
  BitNot
}
pub impl Eq for UnaryOp
pub impl Show for UnaryOp

pub(all) enum UpdateOp {
  Increment
  Decrement
}
pub impl Eq for UpdateOp
pub impl Show for UpdateOp

pub(all) enum VarKind {
  LetKind
  ConstKind
  VarKind
}
pub impl Eq for VarKind
pub impl Show for VarKind

// Type aliases

// Traits

